# jogo-padroes

This template should help get you started developing with Vue 3 in Vite.

## Recommended IDE Setup

[VS Code](https://code.visualstudio.com/) + [Vue (Official)](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur).

## Recommended Browser Setup

- Chromium-based browsers (Chrome, Edge, Brave, etc.):
  - [Vue.js devtools](https://chromewebstore.google.com/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd) 
  - [Turn on Custom Object Formatter in Chrome DevTools](http://bit.ly/object-formatters)
- Firefox:
  - [Vue.js devtools](https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/)
  - [Turn on Custom Object Formatter in Firefox DevTools](https://fxdx.dev/firefox-devtools-custom-object-formatters/)

## Customize configuration

See [Vite Configuration Reference](https://vite.dev/config/).

## Project Setup

```sh
npm install
```

### Compile and Hot-Reload for Development

```sh
npm run dev
```

### Compile and Minify for Production

```sh
npm run build
```

### Lint with [ESLint](https://eslint.org/)

```sh
npm run lint
```
Relatório de Melhores Práticas Arquiteturais para Desenvolvimento Web Moderno (Vue 3, Vite, HTML, CSS, JavaScript)Capítulo I: Fundamentos da Arquitetura Vite e Setup InicialO desenvolvimento de um projeto web moderno, utilizando Vue.js 3 e Vite, baseia-se na adoção de um ecossistema que prioriza a velocidade de desenvolvimento e a performance em produção. O Vite, como ferramenta de build e servidor de desenvolvimento, utiliza Módulos ES Nativos (Native ESM) durante o desenvolvimento, o que resulta em um tempo de inicialização a frio (cold start) significativamente mais rápido do que bundlers tradicionais baseados em JavaScript.11.1 O Ecossistema Moderno: Vue 3, Composition API e ViteA escolha do Vue 3 em conjunto com a Composition API é fundamental para a escalabilidade e manutenção do projeto. A Composition API permite uma maior reusabilidade e a organização lógica de código por funcionalidade, ao invés de por tipo de opção (como data, methods e computed).2 Este modelo é o recomendado para a construção de aplicações completas (Single-Page Applications – SPAs).2A estrutura de diretórios do projeto deve refletir a separação de preocupações e a hierarquia da aplicação.Diretório/ArquivoPropósito PrimárioRelevância Arquiteturalindex.htmlPonto de entrada SPAShell minimalista para maximizar a performance de carregamento.3src/main.jsInicialização da AplicaçãoMonta a instância do Vue, importa o roteador e o gerenciador de estado. Deve usar a sintaxe de módulo.4src/assets/Ativos ProcessadosLocal para ativos que requerem otimização, compressão ou cache busting.5src/components/Componentes ReutilizáveisUnidades isoladas de UI (Atoms, Molecules, Organisms).6src/views/Componentes de Nível de RotaMapeados diretamente para URLs. Usados primariamente para orquestração de componentes e obtenção de dados de domínio.src/router/index.jsConfiguração de RoteamentoDefine as rotas da aplicação, implementando obrigatoriamente lazy loading.7src/stores/Gerenciamento de Estado (Pinia)Módulos de estado por domínio/feature, garantindo separação de preocupações.81.2 Otimização da Inicialização: O Arquivo index.htmlEm uma SPA baseada em Vue e Vite, o index.html não é um documento estrutural completo, mas sim um shell de carregamento. O objetivo é mantê-lo o mais leve possível para melhorar a Performance de Carregamento de Página e as métricas vitais da web, como o LCP (Largest Contentful Paint).3Melhores Práticas para index.html:Minimalismo Essencial: O corpo (<body>) deve ser quase vazio, contendo apenas o elemento de montagem do Vue (<div id="app"></div>) e tags de metadados essenciais (viewport, charset, etc.).Referência de Módulo: O script principal deve ser referenciado usando a sintaxe de módulo nativa do ECMAScript: <script type="module" src="/src/main.js"></script>.4 Esta prática é crucial, pois permite que o Vite use módulos ES nativos no navegador durante o desenvolvimento, acelerando drasticamente o carregamento.CSS Global: Se houver necessidade de CSS global (como base.css ou main.css) que deve ser carregado antes da hidratação do Vue para evitar FOUC (Flash of Unstyled Content), a importação via src/main.js é o método preferencial. Isso permite que o Vite processe os estilos e lide com o HMR (Hot Module Replacement).1Arquiteturalmente, o index.html deve servir como um "carregador" e não como um contentor de estilos ou lógica. Ao delegar o carregamento de CSS e JS ao src/main.js, o projeto se beneficia da modularidade e do code splitting automáticos fornecidos pelo Vite/Rollup.Capítulo II: Gerenciamento Inteligente de Ativos EstáticosA forma como os ativos (imagens, ícones, fontes) são gerenciados tem um impacto direto na performance do build e nas estratégias de caching em produção. O Vite estabelece uma distinção clara entre a pasta public e a pasta src/assets/.2.1 A Diferença Crucial: public vs. src/assetsA distinção fundamental reside no processamento pelo bundler.9A decisão de onde colocar um ativo baseia-se se ele deve ser otimizado e receber um hash de conteúdo. O principal benefício de usar src/assets é a capacidade do Vite/Rollup de adicionar hashes baseados no conteúdo (content-based hashes) aos nomes dos arquivos, permitindo o cache busting automático.5Melhores Práticas de Gerenciamento de Ativos no ViteCritérioUso Recomendado (src/assets)Uso Exclusivo (public)Processamento/OtimizaçãoSim. Passa por otimização, compressão e tree-shaking.5Não. É copiado verbatim para o diretório de destino.5Cache Busting (Hashing)Sim. Recebe hashes para cache agressivo de longo prazo.Não. URLs estáticas exigem gerenciamento manual de cache.5ReferênciaImportação via JS/Componentes ou alias @/assets/ no template.11Caminho raiz absoluto (ex: /favicon.ico).5Uso IdealImagens de componentes, ícones de UI, logos que se beneficiam de otimização.Favicon, robots.txt, manifest, arquivos grandes de mídia não processados.A regra arquitetural é manter a pasta public o mais minimalista possível.5 Se um ativo não precisa de um caminho de URL estático e previsível ou não é um arquivo de configuração obrigatório de nível raiz (robots.txt), ele deve ser importado via src/assets para aproveitar as otimizações do build e o sistema de cache busting.52.2 Referência Correta a AtivosPara garantir que o Vite possa processar e substituir corretamente os caminhos de ativos em tempo de build:Em Componentes Vue (.vue): O método mais robusto é importar o ativo no bloco <script setup> e referenciá-lo: import logo from '@/assets/logo.png'. Alternativamente, no <template>, o alias @ mapeia para src, facilitando a portabilidade do componente: <img src="@/assets/images/home.png"/>.11Em CSS: Referências a ativos em arquivos CSS devem usar caminhos relativos ou absolutos. O Vite detecta automaticamente url() e as processa.Em index.html (Ativos Públicos): Use caminhos absolutos, sempre começando com /, pois eles serão servidos a partir da raiz do servidor: <link rel="icon" href="/favicon.ico" />.5Capítulo III: Padrões de Estilização Modular e Manutenção do CSSA estrutura de estilos deve ser organizada para garantir a separação de responsabilidades e evitar a proliferação de classes conflitantes.3.1 Hierarquia de Estilos: base.css e main.cssOs estilos globais devem ser divididos logicamente dentro de src/assets/:src/assets/base.css: Este arquivo deve conter estilos de fundação. Inclui o CSS Reset (para padronização entre navegadores) e a definição de variáveis CSS (custom properties) para cores, tipografia e espaçamento. Isso garante que todos os componentes herdem uma base visual consistente.12src/assets/main.css: Contém estilos aplicados globalmente, como o layout da aplicação (#app styling), classes utilitárias de nível superior e importações de fontes. A importação desses arquivos deve ocorrer em src/main.js.3.2 Modularidade e Nomenclatura CSSPara a escalabilidade do CSS, especialmente em projetos grandes, a adoção de uma convenção de nomenclatura é essencial.1. BEM (Block-Element-Modifier): O BEM é a estratégia de nomenclatura baseada em classes mais recomendada para evitar conflitos e gerenciar a especificidade.13 Ao dar nomes estruturados e legíveis às classes, o BEM minimiza a necessidade de seletores complexos e de alta especificidade, facilitando a manutenção.2. Separação Funcional: Estilos que não são de componentes específicos devem ser isolados. Por exemplo, arquivos dedicados a utilities ou layouts específicos podem ser criados e importados em main.css.3.3 Estilos em Componentes Vue: Encapsulamento (scoped) e Profundidade1. Uso de scoped: Para componentes de arquivo único (.vue), o uso do atributo scoped na tag <style> é a melhor prática de encapsulamento.14 Isso modifica o CSS, aplicando-o apenas aos elementos do componente atual, prevenindo vazamento de estilos e conflitos acidentais.2. O uso de Deep Selectors: Ocasionalmente, é necessário estilizar um componente filho (ou um componente de biblioteca de terceiros) a partir do componente pai. Para "perfurar" o encapsulamento, o seletor :deep(.some-class) é a sintaxe recomendada no Vue 3.15É fundamental, no entanto, minimizar o uso de deep selectors. A dependência frequente do :deep() acopla o componente pai ao DOM interno exato do componente filho, anulando os benefícios do encapsulamento e aumentando o custo de manutenção. Componentes reutilizáveis devem ser projetados para aceitar customização via props ou slots para preservar o baixo acoplamento. O seletor de profundidade deve ser reservado para cenários onde a modificação do componente filho é impossível (como com bibliotecas de terceiros).Capítulo IV: Componentes Vue 3 e Composition API (O Core do Projeto)O core de um projeto Vue 3 reside nos componentes. A adoção rigorosa dos padrões da Composition API em conjunto com uma arquitetura modular de componentes é crucial para a longevidade do projeto.4.1 Adoção de <script setup>A sintaxe <script setup> é fortemente recomendada por sua ergonomia e concisão, sendo a forma padrão de utilizar a Composition API em Single-File Components (SFCs).2 Ela reduz o boilerplate, permite que imports e variáveis de nível superior sejam expostas automaticamente ao template, e facilita a declaração de props e emits.4.2 Gerenciamento de Reatividade: ref vs. reactiveA escolha correta entre ref e reactive é um pilar da Composition API.Recomendações para Gerenciamento de Reatividade (Composition API)CenárioOpção RecomendadaJustificativa TécnicaEstado Simples (Primitivos)ref()Rastreamento reativo para valores únicos (primitivos); oferece auto-desembrulhamento no template.2Estado Complexo (Objetos)reactive()Ideal para estruturas que serão alteradas por mutação; evita o uso repetitivo de .value e cria um proxy reativo profundo.Acesso a Propsprops.propNameGarante que o Proxy reativo seja lido, mantendo a reatividade do pai para o filho.2Desestruturação Reativa de PropstoRefs(props)Converte as propriedades do objeto props em refs rastreáveis, permitindo a desestruturação sem perda de reatividade.2Um erro comum que deve ser evitado é a desestruturação direta do objeto props (const { title } = props). Se o objeto props for desestruturado, as variáveis resultantes perdem a reatividade, o que impede a atualização do componente quando o pai muda o valor da propriedade.2 A solução é usar o utilitário toRefs(props) antes da desestruturação, que transforma cada propriedade em uma ref rastreável, mantendo o vínculo reativo.4.3 Propriedades, Eventos e Modularização1. defineProps e defineEmits: Ambos são macros de tempo de compilação disponíveis em <script setup> e são usados para definir a interface pública do componente. Os eventos emitidos devem ser declarados explicitamente usando defineEmits.162. Convenção de Eventos: O Vue transforma automaticamente a caixa (case). Recomenda-se emitir eventos em camelCase no código (emit('increaseBy', 1)), mas os ouvintes no template do pai devem usar kebab-case (@increase-by) para seguir as convenções de HTML.163. Modularização de Componentes (Atomic Design): Para projetos em escala, a organização em camadas Atomic Design melhora drasticamente a reusabilidade e a clareza.6Atoms e Icons (src/components/icons/*): Elementos básicos e puramente visuais (BaseButton, BaseInput).Molecules: Agrupamentos de Atoms com lógica simples (e.g., um formulário de login).Organisms: Componentes complexos de seção que contêm Molecules e Atoms e podem ter lógica de estado robusta (e.g., NavigationBar).17A implicação da arquitetura em camadas é a gestão do acoplamento: Componentes reutilizáveis em src/components/ (Atoms, Molecules, Organisms) não devem depender diretamente de stores Pinia ou do Vue Router. Eles devem receber todos os dados e callbacks via props e comunicar mudanças via emits, garantindo que sejam testáveis e reutilizáveis em qualquer contexto da aplicação.6Capítulo V: Roteamento e Gerenciamento de Estado EscalávelA performance e a manutenção de uma SPA dependem diretamente da configuração eficiente do roteamento e do gerenciamento de estado.5.1 Configuração de Roteamento em src/router/index.jsA configuração do Vue Router deve ser centralizada e priorizar a performance de carregamento.Implementação de Lazy Loading de Rotas: O Lazy Loading é a técnica mais eficaz para otimizar o tempo de carregamento inicial, pois divide o pacote de JavaScript em pedaços menores (chunks), carregando o código de uma rota apenas quando ela é visitada.18A prática correta é substituir a importação estática do componente pela sintaxe de dynamic import na definição das rotas:JavaScript// Má Prática: Importação estática (carrega tudo na inicialização)
// import HomeView from '../views/HomeView.vue'

// Melhor Prática: Lazy Loading
const routes = [
  {
    path: '/',
    name: 'home',
    component: () => import('../views/HomeView.vue')
  }
];
O uso de import() dinâmico sinaliza ao Rollup (o bundler do Vite) onde criar pontos de divisão de código, garantindo que os componentes de nível de src/views/ sejam carregados sob demanda, melhorando o LCP da aplicação.35.2 Gestão de Estado com Pinia: Modularidade por DomínioPinia é a biblioteca de gerenciamento de estado recomendada para o Vue 3, oferecendo um design modular e forte suporte a Devtools.19A arquitetura do estado deve ser modularizada por domínio ou recurso (e.g., src/stores/auth.js, src/stores/user.js). Evitar um arquivo de store monolítico é crucial, pois resulta em código inchado e falta de separação de preocupações.8Estrutura e Organização de Stores no PiniaComponente do StorePropósitoMelhor PráticaStateO estado central da aplicação (dados brutos).Manter a estrutura simples, representando a verdade única do domínio.GettersEstado derivado ou computado.Usar para lógica de leitura complexa; mantém os componentes limpos.8ActionsLógica de negócio, mutações assíncronas/síncronas.Devem ser focadas, isolando a lógica de API e manipulação de estado.ArquiteturaModularização de StoresUma store por recurso/domínio para separação de preocupações e otimização do code splitting.8A modularização do Pinia, combinada com o lazy loading de rotas, cria uma sinergia de performance. Como o Pinia é modular por design 19, se um store for importado apenas por um componente que está sendo carregado sob demanda, o código desse store também será carregado de forma assíncrona, maximizando a eficiência de carregamento.Capítulo VI: Quality Assurance (Tooling e Padrões de Codificação)A qualidade do código, clareza e manutenção são mantidas através da imposição de padrões automatizados usando ferramentas de linting e formatação.6.1 Regras de Linting, Formatação (ESLint, Prettier)ESLint deve ser configurado para impor regras de qualidade de código (potenciais bugs e padrões Vue-specific), enquanto Prettier deve ser dedicado exclusivamente à formatação estética do código (espaçamento, aspas).20Configuração Anticonflito: A integração correta de Prettier e ESLint requer o pacote eslint-config-prettier. No arquivo .eslintrc.js, a configuração do prettier deve ser o último item na array extends ("extends": [..., "prettier"]).20 Essa ordem de prioridade garante que quaisquer regras de formatação do ESLint que possam entrar em conflito com o Prettier sejam desativadas, permitindo que cada ferramenta cumpra sua função sem duplicação de relatórios de erro.O uso de plugins do Vite, como o vite-plugin-eslint, é recomendado para exibir erros de linting diretamente no navegador durante o desenvolvimento.206.2 Padrões de Codificação JavaScript Moderno (ES6+)O projeto deve utilizar os padrões modernos do ECMAScript (ES6+) para melhorar a legibilidade e a eficiência. O Vite e os navegadores modernos suportam nativamente esses padrões.4Módulos ES: Utilização consistente de import/export em todos os arquivos (.js, .vue).Funções de Seta (=>): Uso preferencial para funções anônimas e callbacks, eliminando problemas de vinculação de this.21Assíncrono/Aguardar (async/await): Uso padrão para lidar com promessas, substituindo cadeias complexas de .then().Desestruturação: Uso para extração limpa de dados, como ao extrair props reativas usando toRefs().6.3 Gerenciamento de Dependências e Scripts do Vite1. package.json: A separação correta de dependências é vital para o tamanho do build de produção.22dependencies: Pacotes necessários para a execução da aplicação em produção (vue, pinia, vue-router).devDependencies: Pacotes utilizados apenas durante o desenvolvimento e a construção (vite, eslint, prettier).2. Scripts e Otimização: O package.json deve incluir scripts claros (dev, build, lint). Para garantir um cold start rápido, o Vite pré-empacota dependências.1 Em casos em que uma dependência não é facilmente detectável ou não exporta um módulo ES nativo, ela deve ser explicitamente incluída no optimizeDeps.include dentro do vite.config.js. Isso garante que o servidor de desenvolvimento inicie de forma estável e rápida.23Capítulo VII: Manutenção, Performance e DocumentaçãoA manutenção a longo prazo é sustentada por documentação clara e foco contínuo em otimizações de runtime e build.7.1 Boas Práticas de Integração para PerformanceA performance não termina com o lazy loading.Tree Shaking: O Vite, que usa o Rollup, executa a eliminação de código morto (Dead Code Elimination). A arquitetura modular do projeto (Composition API, Pinia, Módulos ES) maximiza a eficácia do Tree Shaking, removendo código não utilizado no bundle final.3Otimização de Ferramentas: Para manter os tempos de build e desenvolvimento rápidos, é recomendável otimizar a pilha de ferramentas, possivelmente preferindo o uso de CSS nativo com PostCSS (para aninhamento) em vez de pré-processadores pesados como Sass ou Less, quando possível.24Code Splitting Adicional: Além das rotas, grandes módulos de utilitários ou de composables que são usados apenas em partes específicas da aplicação devem ser carregados via dynamic imports para otimizar ainda mais os chunks de código.37.2 Comentários e Documentação de Código (JSDoc)A documentação interna é essencial para a clareza do código e o onboarding de novos desenvolvedores.1. JSDoc: O JSDoc deve ser o padrão para documentar a API de todas as funções complexas, composables, actions de Pinia e módulos de utilitários em src/utils.25 O JSDoc permite a descrição detalhada de parâmetros, tipos de retorno e propósito das funções, auxiliando as IDEs com autocompletar e tipagem, mesmo em projetos JavaScript.262. Documentação de Componentes: Em componentes de arquivo único, comentários devem ser usados para descrever a função do componente, as props esperadas e os eventos emitidos, facilitando a compreensão da interface do componente sem a necessidade de ferramentas externas, embora ferramentas de geração de documentação de componentes possam ser integradas para grandes projetos.7.3 O Arquivo README.md: Guia EssencialO arquivo README é o primeiro ponto de contato e deve ser um guia exaustivo para instalação e uso.27A estrutura do README deve ser abrangente, incluindo os seguintes elementos essenciais:Título, Badges e Resumo: Identificação imediata e status do projeto (licença, status de build).28Descrição e Motivação: Explicação clara do que o projeto faz.Tech Stack: Lista das tecnologias principais (HTML, CSS, Vue.js, Vite, Pinia).28Instalação e Setup: Passo-a-passo detalhado, incluindo clonagem do repositório, npm install e pré-requisitos (como a versão Node.js).27Scripts de Uso: Instruções claras sobre como iniciar o servidor de desenvolvimento (npm run dev), construir para produção (npm run build) e executar ferramentas de QA (npm run lint).Como Usar: Instruções de alto nível sobre as principais funcionalidades e, idealmente, uma demonstração visual (prints de tela ou GIF).27Contribuição e Licença: Regras para contribuição e o tipo de licença do projeto.Conclusões e RecomendaçõesO desenvolvimento de um projeto web moderno com Vue 3 e Vite, seguindo a estrutura fornecida, deve ser guiado por princípios de performance orientados pelo build e modularidade estrita.Prioridade de Performance (Build-Time): A otimização do carregamento inicial (LCP) é alcançada primariamente pela adoção irrestrita do Lazy Loading via dynamic imports em todas as rotas em src/views/ e, crucialmente, pela modularização do estado Pinia em src/stores/. Essa sinergia garante que apenas o código necessário seja carregado sob demanda.18Manutenibilidade via Modularidade: O projeto se beneficia da organização por camadas (Atomic Design em src/components/), que isola unidades de UI, e pela aplicação de baixo acoplamento. Componentes de UI de baixo nível devem se comunicar estritamente via props e emits, evitando o acesso direto ao estado global ou ao roteador.6Qualidade e Consistência: A aplicação de regras rigorosas de ESLint e a formatação automatizada pelo Prettier garantem a consistência do código. A regra crítica para prevenir bugs de reatividade é a imposição da Composition API, especialmente o uso de toRefs() ou o acesso direto a props.propName para evitar a perda de rastreamento reativo.2Gerenciamento de Ativos Otimizado: O uso de src/assets/ para todos os ativos que se beneficiam do cache busting (hashing de conteúdo) é o padrão. A pasta public deve ser mantida minimalista e reservada para arquivos que exigem caminhos absolutos no nível raiz.5A aplicação consistente dessas melhores práticas resultará em uma aplicação Vue 3 que é performática em produção, rápida de desenvolver e altamente manutenível em escala.
